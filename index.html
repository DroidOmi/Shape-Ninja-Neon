<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#43a047">
<link rel="apple-touch-icon" href="icon-192x192.png"">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glowing Fruit Ninja</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Orbitron', monospace;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            overflow: hidden;
            height: 100vh;
            cursor: none;
            touch-action: none;
            user-select: none;
        }
        
        #gameCanvas {
            display: block;
            background: radial-gradient(circle at center, rgba(255,255,255,0.05) 0%, transparent 70%);
            cursor: none;
        }
        
        #gameUI {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
        
        #score {
            position: absolute;
            top: clamp(15px, 3vw, 30px);
            left: clamp(15px, 3vw, 30px);
            color: white;
            font-size: clamp(1.5rem, 4vw, 2.5rem);
            font-weight: 700;
            text-shadow: 0 0 20px rgba(255,255,255,0.8);
        }
        
        #highScore {
            position: absolute;
            top: clamp(60px, 8vw, 80px);
            left: clamp(15px, 3vw, 30px);
            color: #ffd700;
            font-size: clamp(1rem, 3vw, 1.5rem);
            font-weight: 700;
            text-shadow: 0 0 15px rgba(255,215,0,0.8);
        }
        
        #lives {
            position: absolute;
            top: clamp(15px, 3vw, 30px);
            right: clamp(15px, 3vw, 30px);
            color: white;
            font-size: clamp(1rem, 3vw, 1.5rem);
            font-weight: 700;
        }
        
        .heart {
            display: inline-block;
            margin: 0 5px;
            color: #ff4757;
            text-shadow: 0 0 15px rgba(255,71,87,0.8);
        }
        
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: white;
            display: none;
            pointer-events: all;
            background: rgba(0,0,0,0.8);
            padding: clamp(20px, 5vw, 40px);
            border-radius: 20px;
            border: 2px solid rgba(255,255,255,0.3);
        }
        
        #gameOver h1 {
            font-size: clamp(2rem, 8vw, 4rem);
            font-weight: 900;
            margin-bottom: 20px;
            text-shadow: 0 0 30px rgba(255,255,255,0.8);
            color: #ff6b6b;
        }
        
        #gameOver p {
            font-size: clamp(1rem, 4vw, 1.5rem);
            margin-bottom: 30px;
        }
        
        #restartBtn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            padding: clamp(12px, 3vw, 18px) clamp(24px, 6vw, 36px);
            font-size: clamp(1rem, 3vw, 1.3rem);
            font-weight: 700;
            color: white;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-family: 'Orbitron', monospace;
            box-shadow: 0 10px 30px rgba(255,107,107,0.4);
        }
        
        #restartBtn:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(255,107,107,0.6);
        }
        
        #cursor {
            position: absolute;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(255,255,255,0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 1000;
            transition: all 0.1s ease;
            box-shadow: 0 0 20px rgba(255,255,255,0.6);
            display: none;
        }
        
        @keyframes scorePopup {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        .score-popup {
            animation: scorePopup 0.3s ease;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div id="cursor"></div>
    
    <div id="gameUI">
        <div id="score">0</div>
        <div id="highScore">Best: 0</div>
        <div id="lives">
            <span class="heart">♥</span>
            <span class="heart">♥</span>
            <span class="heart">♥</span>
        </div>
        
        <div id="gameOver">
            <h1>GAME OVER</h1>
            <p>Final Score: <span id="finalScore">0</span></p>
            <button id="restartBtn">PLAY AGAIN</button>
        </div>
    </div>

    <script>
        class FruitNinjaGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.cursor = document.getElementById('cursor');
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.score = 0;
                this.highScore = parseInt(localStorage.getItem('fruitNinjaHighScore')) || 0;
                this.lives = 3;
                this.fruits = [];
                this.particles = [];
                this.slashTrail = [];
                this.gameRunning = true;
                this.mousePos = { x: 0, y: 0 };
                this.lastMousePos = { x: 0, y: 0 };
                this.isSlashing = false;
                
                this.fruitTypes = [
                    { color: '#ff6b6b', name: 'apple', shape: 'circle' },
                    { color: '#ffa726', name: 'orange', shape: 'hexagon' },
                    { color: '#66bb6a', name: 'lime', shape: 'diamond' },
                    { color: '#ab47bc', name: 'grape', shape: 'square' },
                    { color: '#ffeb3b', name: 'banana', shape: 'triangle' },
                    { color: '#f06292', name: 'strawberry', shape: 'heart' },
                    { color: '#42a5f5', name: 'blueberry', shape: 'circle' },
                    { color: '#26c6da', name: 'mint', shape: 'diamond' }
                ];
                
                this.bombType = { color: '#2c2c2c', name: 'bomb', shape: 'circle' };
                
                this.setupEventListeners();
                this.updateHighScoreDisplay();
                this.gameLoop();
                this.spawnFruits();
            }
            
            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            setupEventListeners() {
                document.addEventListener('mousemove', (e) => {
                    this.handleMove(e.clientX, e.clientY);
                });
                
                document.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    this.startSlashing(e.clientX, e.clientY);
                });
                
                document.addEventListener('mouseup', () => {
                    this.stopSlashing();
                });
                
                document.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.startSlashing(touch.clientX, touch.clientY);
                }, { passive: false });
                
                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    this.handleMove(touch.clientX, touch.clientY);
                }, { passive: false });
                
                document.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.stopSlashing();
                }, { passive: false });
                
                document.getElementById('restartBtn').addEventListener('click', () => {
                    this.restart();
                });
                
                document.getElementById('restartBtn').addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.restart();
                }, { passive: false });
            }
            
            handleMove(x, y) {
                this.lastMousePos = { ...this.mousePos };
                this.mousePos = { x, y };
                
                this.cursor.style.left = (x - 15) + 'px';
                this.cursor.style.top = (y - 15) + 'px';
                
                if (this.isSlashing) {
                    this.addSlashTrail();
                    this.checkFruitSlicing();
                }
            }
            
            startSlashing(x, y) {
                this.isSlashing = true;
                this.mousePos = { x, y };
                this.cursor.style.display = 'block';
                this.cursor.style.borderColor = '#ff6b6b';
                this.cursor.style.transform = 'scale(1.3)';
                this.cursor.style.boxShadow = '0 0 30px rgba(255,107,107,0.9)';
            }
            
            stopSlashing() {
                this.isSlashing = false;
                this.cursor.style.display = 'none';
                this.cursor.style.borderColor = 'rgba(255,255,255,0.8)';
                this.cursor.style.transform = 'scale(1)';
                this.cursor.style.boxShadow = '0 0 20px rgba(255,255,255,0.6)';
            }
            
            addSlashTrail() {
                const distance = Math.sqrt(
                    Math.pow(this.mousePos.x - this.lastMousePos.x, 2) + 
                    Math.pow(this.mousePos.y - this.lastMousePos.y, 2)
                );
                
                if (distance > 5) {
                    this.slashTrail.push({
                        x: this.mousePos.x,
                        y: this.mousePos.y,
                        life: 1.0
                    });
                    
                    if (this.slashTrail.length > 15) {
                        this.slashTrail.shift();
                    }
                }
            }
            
            spawnFruits() {
                if (!this.gameRunning) return;
                
                const spawnFruit = () => {
                    if (Math.random() < 0.8) {
                        let fruitType;
                        let isBomb = false;
                        
                        if (Math.random() < 0.15) {
                            fruitType = this.bombType;
                            isBomb = true;
                        } else {
                            fruitType = this.fruitTypes[Math.floor(Math.random() * this.fruitTypes.length)];
                        }
                        
                        const startX = Math.random() * this.canvas.width;
                        const velocityX = (Math.random() - 0.5) * 10;
                        const velocityY = -18 - Math.random() * 10;
                        
                        this.fruits.push({
                            x: startX,
                            y: this.canvas.height + 50,
                            vx: velocityX,
                            vy: velocityY,
                            rotation: 0,
                            rotationSpeed: (Math.random() - 0.5) * 0.2,
                            size: 25 + Math.random() * 15,
                            color: fruitType.color,
                            shape: fruitType.shape,
                            type: fruitType.name,
                            sliced: false,
                            gravity: 0.4,
                            isBomb: isBomb,
                            glowPhase: Math.random() * Math.PI * 2
                        });
                    }
                };
                
                spawnFruit();
                setTimeout(() => this.spawnFruits(), 1000 + Math.random() * 1500);
            }
            
            updateFruits() {
                for (let i = this.fruits.length - 1; i >= 0; i--) {
                    const fruit = this.fruits[i];
                    
                    if (!fruit.sliced) {
                        fruit.vy += fruit.gravity;
                        fruit.x += fruit.vx;
                        fruit.y += fruit.vy;
                        fruit.rotation += fruit.rotationSpeed;
                        fruit.glowPhase += 0.1;
                        
                        // Bounce only off left and right edges
                        if (fruit.x - fruit.size < 0) {
                            fruit.x = fruit.size;
                            fruit.vx = Math.abs(fruit.vx) * 0.8; // Bounce back with reduced velocity
                        } else if (fruit.x + fruit.size > this.canvas.width) {
                            fruit.x = this.canvas.width - fruit.size;
                            fruit.vx = -Math.abs(fruit.vx) * 0.8; // Bounce back with reduced velocity
                        }
                        
                        // Remove fruits that fall below the screen
                        if (fruit.y - fruit.size > this.canvas.height + 100) {
                            this.fruits.splice(i, 1);
                            if (!fruit.isBomb) {
                                this.loseLife();
                            }
                            continue;
                        }
                    } else {
                        fruit.fadeTimer -= 0.03;
                        if (fruit.fadeTimer <= 0) {
                            this.fruits.splice(i, 1);
                        }
                    }
                }
            }
            
            checkFruitSlicing() {
                for (let i = this.fruits.length - 1; i >= 0; i--) {
                    const fruit = this.fruits[i];
                    if (!fruit.sliced && this.checkSlashPath(fruit)) {
                        this.sliceFruit(fruit, i);
                    }
                }
            }
            
            checkSlashPath(fruit) {
                if (this.slashTrail.length < 2) return false;
                
                for (let j = 1; j < this.slashTrail.length; j++) {
                    const current = this.slashTrail[j];
                    const previous = this.slashTrail[j - 1];
                    
                    if (this.lineIntersectsCircle(previous, current, fruit)) {
                        return true;
                    }
                }
                return false;
            }
            
            lineIntersectsCircle(lineStart, lineEnd, circle) {
                const dx = lineEnd.x - lineStart.x;
                const dy = lineEnd.y - lineStart.y;
                const fx = lineStart.x - circle.x;
                const fy = lineStart.y - circle.y;
                
                const a = dx * dx + dy * dy;
                const b = 2 * (fx * dx + fy * dy);
                const c = (fx * fx + fy * fy) - circle.size * circle.size;
                
                const discriminant = b * b - 4 * a * c;
                
                if (discriminant < 0) return false;
                
                const discriminantSqrt = Math.sqrt(discriminant);
                const t1 = (-b - discriminantSqrt) / (2 * a);
                const t2 = (-b + discriminantSqrt) / (2 * a);
                
                return (t1 >= 0 && t1 <= 1) || (t2 >= 0 && t2 <= 1);
            }
            
            sliceFruit(fruit, index) {
                fruit.sliced = true;
                fruit.fadeTimer = 1.0;
                fruit.sliceTime = Date.now();
                
                if (fruit.isBomb) {
                    this.explodeBomb(fruit);
                    this.gameOver();
                    return;
                } else {
                    this.score += 10;
                    this.updateScore();
                }
                
                this.createSliceParticles(fruit);
                this.addScreenShake();
            }
            
            createSliceParticles(fruit) {
                for (let i = 0; i < 20; i++) {
                    const angle = (Math.PI * 2 * i) / 20;
                    const speed = 3 + Math.random() * 6;
                    this.particles.push({
                        x: fruit.x,
                        y: fruit.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.0,
                        color: fruit.color,
                        size: 3 + Math.random() * 4,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.3
                    });
                }
            }
            
            explodeBomb(bomb) {
                for (let i = 0; i < 40; i++) {
                    const angle = (Math.PI * 2 * i) / 40;
                    const speed = 5 + Math.random() * 10;
                    this.particles.push({
                        x: bomb.x,
                        y: bomb.y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 1.5,
                        color: '#ff4444',
                        size: 4 + Math.random() * 6,
                        rotation: Math.random() * Math.PI * 2,
                        rotationSpeed: (Math.random() - 0.5) * 0.4
                    });
                }
                
                this.screenShake = {
                    intensity: 15,
                    duration: 0.8,
                    timer: 0.8
                };
            }
            
            addScreenShake() {
                this.screenShake = {
                    intensity: 5,
                    duration: 0.2,
                    timer: 0.2
                };
            }
            
            updateParticles() {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const particle = this.particles[i];
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    particle.vy += 0.2;
                    particle.life -= 0.02;
                    particle.size *= 0.98;
                    
                    if (particle.rotation !== undefined) {
                        particle.rotation += particle.rotationSpeed;
                    }
                    
                    particle.vx *= 0.99;
                    particle.vy *= 0.99;
                    
                    if (particle.life <= 0) {
                        this.particles.splice(i, 1);
                    }
                }
                
                if (this.screenShake && this.screenShake.timer > 0) {
                    this.screenShake.timer -= 0.016;
                    if (this.screenShake.timer <= 0) {
                        this.screenShake = null;
                    }
                }
            }
            
            updateSlashTrail() {
                for (let i = this.slashTrail.length - 1; i >= 0; i--) {
                    const trail = this.slashTrail[i];
                    trail.life -= 0.08;
                    
                    if (trail.life <= 0) {
                        this.slashTrail.splice(i, 1);
                    }
                }
            }
            
            drawFruit(fruit) {
                this.ctx.save();
                
                if (this.screenShake && this.screenShake.timer > 0) {
                    const shakeX = (Math.random() - 0.5) * this.screenShake.intensity;
                    const shakeY = (Math.random() - 0.5) * this.screenShake.intensity;
                    this.ctx.translate(shakeX, shakeY);
                }
                
                this.ctx.translate(fruit.x, fruit.y);
                this.ctx.rotate(fruit.rotation);
                
                if (!fruit.sliced) {
                    const glowIntensity = 0.6 + Math.sin(fruit.glowPhase) * 0.3;
                    
                    // Draw outer glow
                    const outerGlow = this.ctx.createRadialGradient(0, 0, 0, 0, 0, fruit.size * 3);
                    if (fruit.isBomb) {
                        outerGlow.addColorStop(0, `rgba(255, 68, 68, ${glowIntensity * 0.4})`);
                        outerGlow.addColorStop(0.5, `rgba(255, 68, 68, ${glowIntensity * 0.2})`);
                    } else {
                        const r = parseInt(fruit.color.slice(1, 3), 16);
                        const g = parseInt(fruit.color.slice(3, 5), 16);
                        const b = parseInt(fruit.color.slice(5, 7), 16);
                        outerGlow.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${glowIntensity * 0.4})`);
                        outerGlow.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${glowIntensity * 0.2})`);
                    }
                    outerGlow.addColorStop(1, 'transparent');
                    
                    this.ctx.fillStyle = outerGlow;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, fruit.size * 3, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw middle glow
                    const middleGlow = this.ctx.createRadialGradient(0, 0, 0, 0, 0, fruit.size * 1.8);
                    if (fruit.isBomb) {
                        middleGlow.addColorStop(0, `rgba(255, 68, 68, ${glowIntensity * 0.6})`);
                        middleGlow.addColorStop(0.7, `rgba(255, 68, 68, ${glowIntensity * 0.3})`);
                    } else {
                        const r = parseInt(fruit.color.slice(1, 3), 16);
                        const g = parseInt(fruit.color.slice(3, 5), 16);
                        const b = parseInt(fruit.color.slice(5, 7), 16);
                        middleGlow.addColorStop(0, `rgba(${r}, ${g}, ${b}, ${glowIntensity * 0.6})`);
                        middleGlow.addColorStop(0.7, `rgba(${r}, ${g}, ${b}, ${glowIntensity * 0.3})`);
                    }
                    middleGlow.addColorStop(1, 'transparent');
                    
                    this.ctx.fillStyle = middleGlow;
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, fruit.size * 1.8, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw main shape
                    this.drawShape(fruit, glowIntensity);
                    
                    // Draw bomb details
                    if (fruit.isBomb) {
                        this.drawBombDetails(fruit);
                    }
                } else {
                    // Draw sliced fruit pieces
                    this.ctx.globalAlpha = fruit.fadeTimer;
                    
                    const timeSinceSlice = (Date.now() - fruit.sliceTime) / 1000;
                    const pieceSize = fruit.size * 0.7;
                    
                    // Left piece
                    this.ctx.save();
                    this.ctx.translate(-pieceSize * 0.4, 0);
                    this.ctx.rotate(timeSinceSlice * 3);
                    this.drawShape({ ...fruit, size: pieceSize }, 0.5);
                    this.ctx.restore();
                    
                    // Right piece
                    this.ctx.save();
                    this.ctx.translate(pieceSize * 0.4, 0);
                    this.ctx.rotate(-timeSinceSlice * 3);
                    this.drawShape({ ...fruit, size: pieceSize }, 0.5);
                    this.ctx.restore();
                }
                
                this.ctx.restore();
            }
            
            drawShape(fruit, glowIntensity) {
                const gradient = this.ctx.createRadialGradient(0, 0, 0, 0, 0, fruit.size);
                
                if (fruit.isBomb) {
                    gradient.addColorStop(0, '#666666');
                    gradient.addColorStop(0.7, fruit.color);
                    gradient.addColorStop(1, '#111111');
                } else {
                    const r = parseInt(fruit.color.slice(1, 3), 16);
                    const g = parseInt(fruit.color.slice(3, 5), 16);
                    const b = parseInt(fruit.color.slice(5, 7), 16);
                    
                    gradient.addColorStop(0, `rgb(${Math.min(255, r + 80)}, ${Math.min(255, g + 80)}, ${Math.min(255, b + 80)})`);
                    gradient.addColorStop(0.3, `rgb(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)})`);
                    gradient.addColorStop(0.7, fruit.color);
                    gradient.addColorStop(1, `rgb(${Math.max(0, r - 60)}, ${Math.max(0, g - 60)}, ${Math.max(0, b - 60)})`);
                }
                
                this.ctx.fillStyle = gradient;
                
                switch(fruit.shape) {
                    case 'circle':
                        this.ctx.beginPath();
                        this.ctx.arc(0, 0, fruit.size, 0, Math.PI * 2);
                        this.ctx.fill();
                        
                        // Add inner circle detail
                        if (!fruit.isBomb) {
                            this.ctx.strokeStyle = `rgba(255, 255, 255, 0.3)`;
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, fruit.size * 0.7, 0, Math.PI * 2);
                            this.ctx.stroke();
                        }
                        break;
                        
                    case 'square':
                        this.ctx.fillRect(-fruit.size, -fruit.size, fruit.size * 2, fruit.size * 2);
                        
                        // Add border detail
                        if (!fruit.isBomb) {
                            this.ctx.strokeStyle = `rgba(255, 255, 255, 0.4)`;
                            this.ctx.lineWidth = 3;
                            this.ctx.strokeRect(-fruit.size * 0.8, -fruit.size * 0.8, fruit.size * 1.6, fruit.size * 1.6);
                        }
                        break;
                        
                    case 'triangle':
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -fruit.size);
                        this.ctx.lineTo(-fruit.size * 0.9, fruit.size * 0.7);
                        this.ctx.lineTo(fruit.size * 0.9, fruit.size * 0.7);
                        this.ctx.closePath();
                        this.ctx.fill();
                        
                        // Add inner triangle detail
                        if (!fruit.isBomb) {
                            this.ctx.strokeStyle = `rgba(255, 255, 255, 0.4)`;
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, -fruit.size * 0.6);
                            this.ctx.lineTo(-fruit.size * 0.5, fruit.size * 0.3);
                            this.ctx.lineTo(fruit.size * 0.5, fruit.size * 0.3);
                            this.ctx.closePath();
                            this.ctx.stroke();
                        }
                        break;
                        
                    case 'heart':
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, fruit.size * 0.3);
                        this.ctx.bezierCurveTo(-fruit.size * 0.5, -fruit.size * 0.7, -fruit.size * 1.2, fruit.size * 0.1, 0, fruit.size);
                        this.ctx.bezierCurveTo(fruit.size * 1.2, fruit.size * 0.1, fruit.size * 0.5, -fruit.size * 0.7, 0, fruit.size * 0.3);
                        this.ctx.fill();
                        
                        // Add heart detail
                        if (!fruit.isBomb) {
                            this.ctx.fillStyle = `rgba(255, 255, 255, 0.3)`;
                            this.ctx.beginPath();
                            this.ctx.arc(-fruit.size * 0.3, -fruit.size * 0.2, fruit.size * 0.15, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        break;
                        
                    case 'diamond':
                        this.ctx.beginPath();
                        this.ctx.moveTo(0, -fruit.size);
                        this.ctx.lineTo(fruit.size * 0.7, 0);
                        this.ctx.lineTo(0, fruit.size);
                        this.ctx.lineTo(-fruit.size * 0.7, 0);
                        this.ctx.closePath();
                        this.ctx.fill();
                        
                        // Add diamond facets
                        if (!fruit.isBomb) {
                            this.ctx.strokeStyle = `rgba(255, 255, 255, 0.5)`;
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, -fruit.size);
                            this.ctx.lineTo(0, fruit.size);
                            this.ctx.moveTo(-fruit.size * 0.7, 0);
                            this.ctx.lineTo(fruit.size * 0.7, 0);
                            this.ctx.stroke();
                        }
                        break;
                        
                    case 'hexagon':
                        this.ctx.beginPath();
                        for (let i = 0; i < 6; i++) {
                            const angle = (i * Math.PI) / 3;
                            const x = Math.cos(angle) * fruit.size;
                            const y = Math.sin(angle) * fruit.size;
                            if (i === 0) {
                                this.ctx.moveTo(x, y);
                            } else {
                                this.ctx.lineTo(x, y);
                            }
                        }
                        this.ctx.closePath();
                        this.ctx.fill();
                        
                        // Add hexagon pattern
                        if (!fruit.isBomb) {
                            this.ctx.strokeStyle = `rgba(255, 255, 255, 0.4)`;
                            this.ctx.lineWidth = 2;
                            this.ctx.beginPath();
                            for (let i = 0; i < 6; i++) {
                                const angle = (i * Math.PI) / 3;
                                const x = Math.cos(angle) * fruit.size * 0.6;
                                const y = Math.sin(angle) * fruit.size * 0.6;
                                if (i === 0) {
                                    this.ctx.moveTo(x, y);
                                } else {
                                    this.ctx.lineTo(x, y);
                                }
                            }
                            this.ctx.closePath();
                            this.ctx.stroke();
                        }
                        break;
                }
                
                // Add highlight
                if (!fruit.isBomb && glowIntensity) {
                    const highlightGradient = this.ctx.createRadialGradient(
                        -fruit.size * 0.3, -fruit.size * 0.3, 0,
                        -fruit.size * 0.3, -fruit.size * 0.3, fruit.size * 0.8
                    );
                    highlightGradient.addColorStop(0, `rgba(255, 255, 255, ${glowIntensity * 0.6})`);
                    highlightGradient.addColorStop(0.5, `rgba(255, 255, 255, ${glowIntensity * 0.3})`);
                    highlightGradient.addColorStop(1, 'transparent');
                    
                    this.ctx.fillStyle = highlightGradient;
                    
                    // Apply highlight to the same shape
                    switch(fruit.shape) {
                        case 'circle':
                            this.ctx.beginPath();
                            this.ctx.arc(0, 0, fruit.size, 0, Math.PI * 2);
                            this.ctx.fill();
                            break;
                        case 'square':
                            this.ctx.fillRect(-fruit.size, -fruit.size, fruit.size * 2, fruit.size * 2);
                            break;
                        case 'triangle':
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, -fruit.size);
                            this.ctx.lineTo(-fruit.size * 0.9, fruit.size * 0.7);
                            this.ctx.lineTo(fruit.size * 0.9, fruit.size * 0.7);
                            this.ctx.closePath();
                            this.ctx.fill();
                            break;
                        case 'heart':
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, fruit.size * 0.3);
                            this.ctx.bezierCurveTo(-fruit.size * 0.5, -fruit.size * 0.7, -fruit.size * 1.2, fruit.size * 0.1, 0, fruit.size);
                            this.ctx.bezierCurveTo(fruit.size * 1.2, fruit.size * 0.1, fruit.size * 0.5, -fruit.size * 0.7, 0, fruit.size * 0.3);
                            this.ctx.fill();
                            break;
                        case 'diamond':
                            this.ctx.beginPath();
                            this.ctx.moveTo(0, -fruit.size);
                            this.ctx.lineTo(fruit.size * 0.7, 0);
                            this.ctx.lineTo(0, fruit.size);
                            this.ctx.lineTo(-fruit.size * 0.7, 0);
                            this.ctx.closePath();
                            this.ctx.fill();
                            break;
                        case 'hexagon':
                            this.ctx.beginPath();
                            for (let i = 0; i < 6; i++) {
                                const angle = (i * Math.PI) / 3;
                                const x = Math.cos(angle) * fruit.size;
                                const y = Math.sin(angle) * fruit.size;
                                if (i === 0) {
                                    this.ctx.moveTo(x, y);
                                } else {
                                    this.ctx.lineTo(x, y);
                                }
                            }
                            this.ctx.closePath();
                            this.ctx.fill();
                            break;
                    }
                }
            }
            
            drawBombDetails(fruit) {
                // Draw fuse
                this.ctx.strokeStyle = '#8B4513';
                this.ctx.lineWidth = 3;
                this.ctx.lineCap = 'round';
                this.ctx.beginPath();
                this.ctx.moveTo(0, -fruit.size);
                this.ctx.lineTo(fruit.size * 0.3, -fruit.size * 1.2);
                this.ctx.stroke();
                
                // Draw sparking fuse tip
                const sparkIntensity = 0.8 + Math.sin(Date.now() * 0.02) * 0.2;
                this.ctx.fillStyle = `rgba(255, 165, 0, ${sparkIntensity})`;
                this.ctx.beginPath();
                this.ctx.arc(fruit.size * 0.3, -fruit.size * 1.2, 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Add warning symbol
                this.ctx.fillStyle = '#ff4444';
                this.ctx.font = `${fruit.size * 0.6}px Arial`;
                this.ctx.textAlign = 'center';
                this.ctx.textBaseline = 'middle';
                this.ctx.fillText('!', 0, 0);
            }
            
            drawParticles() {
                this.particles.forEach(particle => {
                    this.ctx.save();
                    this.ctx.globalAlpha = particle.life;
                    
                    if (particle.rotation !== undefined) {
                        this.ctx.translate(particle.x, particle.y);
                        this.ctx.rotate(particle.rotation);
                        this.ctx.translate(-particle.x, -particle.y);
                    }
                    
                    // Draw particle glow
                    const glowGradient = this.ctx.createRadialGradient(
                        particle.x, particle.y, 0,
                        particle.x, particle.y, particle.size * 2
                    );
                    const r = parseInt(particle.color.slice(1, 3), 16);
                    const g = parseInt(particle.color.slice(3, 5), 16);
                    const b = parseInt(particle.color.slice(5, 7), 16);
                    
                    glowGradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.8)`);
                    glowGradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, 0.4)`);
                    glowGradient.addColorStop(1, 'transparent');
                    
                    this.ctx.fillStyle = glowGradient;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size * 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Draw main particle
                    this.ctx.fillStyle = particle.color;
                    this.ctx.beginPath();
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                });
            }
            
            drawSlashTrail() {
                if (this.slashTrail.length < 2) return;
                
                this.ctx.save();
                
                for (let i = 1; i < this.slashTrail.length; i++) {
                    const current = this.slashTrail[i];
                    const previous = this.slashTrail[i - 1];
                    const alpha = current.life;
                    
                    // Draw outer glow
                    this.ctx.globalAlpha = alpha * 0.3;
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 15;
                    this.ctx.lineCap = 'round';
                    this.ctx.lineJoin = 'round';
                    this.ctx.beginPath();
                    this.ctx.moveTo(previous.x, previous.y);
                    this.ctx.lineTo(current.x, current.y);
                    this.ctx.stroke();
                    
                    // Draw middle trail
                    this.ctx.globalAlpha = alpha * 0.6;
                    this.ctx.strokeStyle = '#ff6b6b';
                    this.ctx.lineWidth = 8;
                    this.ctx.beginPath();
                    this.ctx.moveTo(previous.x, previous.y);
                    this.ctx.lineTo(current.x, current.y);
                    this.ctx.stroke();
                    
                    // Draw core trail
                    this.ctx.globalAlpha = alpha * 0.9;
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.moveTo(previous.x, previous.y);
                    this.ctx.lineTo(current.x, current.y);
                    this.ctx.stroke();
                }
                
                this.ctx.restore();
            }
            
            updateScore() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('score').classList.add('score-popup');
                setTimeout(() => {
                    document.getElementById('score').classList.remove('score-popup');
                }, 300);
                
                // Check and update high score
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('fruitNinjaHighScore', this.highScore.toString());
                    this.updateHighScoreDisplay();
                }
            }
            
            updateHighScoreDisplay() {
                document.getElementById('highScore').textContent = `Best: ${this.highScore}`;
            }
            
            loseLife() {
                this.lives--;
                const hearts = document.querySelectorAll('.heart');
                if (hearts[this.lives]) {
                    hearts[this.lives].style.opacity = '0.3';
                }
                
                if (this.lives <= 0) {
                    this.gameOver();
                }
            }
            
            gameOver() {
                this.gameRunning = false;
                document.getElementById('finalScore').textContent = this.score;
                document.getElementById('gameOver').style.display = 'block';
            }
            
            restart() {
                this.score = 0;
                this.lives = 3;
                this.fruits = [];
                this.particles = [];
                this.slashTrail = [];
                this.gameRunning = true;
                this.screenShake = null;
                
                document.getElementById('score').textContent = '0';
                document.getElementById('gameOver').style.display = 'none';
                
                const hearts = document.querySelectorAll('.heart');
                hearts.forEach(heart => heart.style.opacity = '1');
                
                this.spawnFruits();
            }
            
            render() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.drawSlashTrail();
                this.fruits.forEach(fruit => this.drawFruit(fruit));
                this.drawParticles();
            }
            
            gameLoop() {
                if (this.gameRunning) {
                    this.updateFruits();
                    this.updateParticles();
                    this.updateSlashTrail();
                }
                
                this.render();
                requestAnimationFrame(() => this.gameLoop());
            }
        }
        
        window.addEventListener('load', () => {
            new FruitNinjaGame();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'96c5309db2688fb9',t:'MTc1NDcyMDg3MC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script>
<script>
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', function() {
      navigator.serviceWorker.register('./service-worker.js')
        .then(() => console.log('Service Worker Registered'));
    });
  }
</script>
</body>
</html>
